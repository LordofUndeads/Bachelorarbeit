\section{Theoretische Grundlagen}

\subsection{Polygone}
\subsubsection{Definition}

Ein geschlossener  Streckenzug, also eine Folge von Strecken, welche jeweils einen Endpunkt mit ihrem Vorgänger bzw. Nachfolger gemeinsam haben, bilden ein \textbf{Polygon}.

\begin{wrapfigure}{hr}{0.25\textwidth}
  \centering
  \includegraphics[width=0.2\textwidth]{bilder/dreieck_abc.png}
  \caption[Ein Dreieck als Beispiel für ein Polygon]{\centering Dreieck mit Ecken $A, B, C$ als Beispiel für ein Polygon}
  \label{fig:triangle}
\end{wrapfigure}

Dabei ist es wichtig, dass die Anzahl von Strecken endlich ist. "Das Polygon, [zu Deutsch Vieleck], ist also eine durch eine Folge von Strecken begrenzte ebene Fläche." \cite{polydef}
Das einfachste Beispiel hierfür ist ein Dreicke. Es besitzt die Eckpunkte $A$, $B$ und $C$ und wir daher vom Streckenzug aus den Strecken $\overline{AB}$, $\overline{BC}$, $\overline{CA}$ begrenzt (s. Abbildung \ref{fig:triangle}).
Mit genau diesem Prinzip lassen sich beliebig komplexe Polygone erzeugen und beschreiben. Die Strecken werden auch als \textbf{Seiten} und die Endpunkte dieser Strecken 
als \textbf{Ecken} bezeichnet. 
Es sei angemerkt, dass Kreise, obwohl sie ebenfalls ebene Flächen sind, keine Polygone sind. Das folgt daraus, dass Kreise weder Ecken noch eine Begrenzung aus Strecken besitzen.

\subsubsection{Klassifikation von Polygonen}

Es ist denkbar, dass sich die Seiten des Polygons schneiden oder berühren. Man bezeichnet dieses Polygon als überschlagen.\cite{polydef}
Des weiteren kann man Polygone in regulär und nicht regulär unterteilen.
Ein Polygon mit den $n$ Seiten $a,b,c, \ldots$  und den Innenwinkeln $\alpha ,\beta ,\gamma ,\ldots$ heißt regulär, wenn

\begin{center}
  $a=b=c=\dots$ und  $\alpha =\beta =\gamma =\dotsb$
\end{center}
gilt. In einem regelmäßigen Polygon sind demnach alle Seiten zueinander kongruent und alle Winkel gleich groß. \cite{regpoly}

Eine weitere Unterteilungsmöglichkeit lautet wie folgt.
Ein Polygon heißt \textbf{konvex}, wenn für alle Innenwinkel $\alpha _i~(i \in \mathbb{N})$ gilt:
  $\alpha _i < 180^\circ$ 
Anderenfalls heißt es \textbf{konkav}. \cite{convex}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{bilder/konvex_konkav.png}
  \caption[Zwei Secksecke als Beispiel für konvexe bzw. konkave Polygone]{Zwei Secksecke: links konvex, rechts konkav}
  \label{fig:konvexkonkav}
\end{figure}
\pagebreak 
\subsubsection{Diagonalen}

Außer des Streckenzuges, welcher die äußere Grenze des Polygons bildet, kann man im Polygon selbst auch weitere Strecken definieren, 
welche dann als \textbf{Diagonalen} bezeichnet werden. Mittels dieser Diagonalen ist es möglich, jedes Polygon in Dreiecke zu zerlegen. 
Das wird in den nächsten Kapiteln noch näher erläutert, da dieser Sachverhalt die Grundlage für sämtliche Zerlegungsalgorithmen darstellt. 

\subsubsection{Ear und Ear Tips}

Für den in Kapitel 3.3 beschriebenen \ac{eca} ist es der Begriff des \textbf{Ear} (Ohr) relevant. 
Ein Dreieck, welches aus drei aufeinanderfolgenden Ecken $v_{i_0}, v_{i_1}, v_{i_2}$ des Polygons gebildet wird, ohne dass andere Ecken innerhalb 
dieses Dreiecks liegen oder dass der äußere Streckenzug des Polygons durch die Seiten des Dreiecks geschnitten wird, nennt man Ear. Dabei bildet die 
Strecke $\left\{v_{i_0}, v_{i_2}\right\}$ eine Diagonale des Polygons. Die Ecke $v_{i_1}$ heißt dann \textbf{Ear Tip}.\cite{meister}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{bilder/eartips.PNG}
  \caption[Beispiele für Ear und Ear Tips in Polygonen]{\centering Links ist  $\triangle v_{i_0}, v_{i_1}, v_{i_2}$ Ear und $v_{i_1}$ Ear Tip. In der Mitte und rechts 
  ist $\triangle v_{i_0}, v_{i_1}, v_{i_2}$ kein Ear, da $\left\{v_{i_0}, v_{i_2}\right\}$ keine Diagonale ist. \cite{newAlg}}
  \label{fig:ear_eartip}
\end{figure}

\subsubsection{Sätze über Polygone}

Für Polygone gibt es einige Erkenntnisse, welche für die allgemeine Strukturanalyse von eben diesen oder auch für die Triangulation mittels 
\ac{eca} von Bedeutung sind. \break

\begin{flushleft}
  { \textbf{Satz 1 (Jordan'scher Kurvensatz):}

In der euklidischen Ebene $\mathbb{R}^2$ zerlegt jede geschlossene Jordan-Kurve $C \subset \mathbb{R}^2 $ deren Komplement $\mathbb{R}^2 \setminus C$ 
in zwei disjunkte Gebiete, deren gemeinsamer Rand die Jordankurve $C$ ist und deren Vereinigung zusammen mit die ganze Ebene $\mathbb{R}^2$ ausmacht.
\linebreak Genau eines der beiden Gebiete, das sogenannte \textbf{Innengebiet}, ist eine beschränkte Teilmenge von $\mathbb{R}^2$.
\linebreak Das andere dieser beiden Gebiete ist das sogenannte \textbf{Außengebiet} und unbeschränkt. \cite{jordan}
}
\end{flushleft}

\begin{flushleft}
{ \textbf{Satz 2 (Dreieckszerlegung:)}
  
  Jedes Polygon $P$ mit $n$ Ecken kann mittels Hinzunahme von null oder mehr Diagonalen vollständig in Dreiecke zerlegt werden. \cite{newAlg}}
\end{flushleft}

\begin{flushleft}
  { \textbf{Satz 3 (Anzahl der Diagonalen:)}
  
  Jede Triangulation eines Polygons $P$ mit $n$ Ecken besteht nutzt $(n-3)$ Diagonalen und besteht aus $(n-2)$ Dreiecken. \cite{newAlg}
}
\end{flushleft}

\begin{flushleft}
  \textbf{Satz 4 (Two Ears Theorem:)}
  
  Jedes Polygon $P$ mit $n \geq 4$ Ecken besitzt mindestens zwei nicht überlappende Ears. \cite{twoears}
\end{flushleft}

\subsubsection{Polytope}
Zuletzt sei an dieser Stelle angemerkt, dass ein Polygon die zweidimensionale Ausprägung des topologischen Begriffs des \textbf{Polytops} ist.
Betrachtet man die räumlichen Dimensionen null bis vier in aufsteigender Reihenfolge, so sind ein Punkt, eine Strecke, ein Quadrat, ein Würfel und ein Tesserakt.
Dies ist in der nachstehenden Abbildung zu sehen.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{bilder/Polytope_Dim0_4.png}
  \caption[Beispiele für Polytope der Dimensionen 0 bis 4]{Beispiele für Polytope der Dimensionen 0 bis 4}
  \label{fig:polytope}
\end{figure}

\subsection{Simplexe und Triangulation}

Wie bereits angesprochen, kann man durch Hinzufügen von Diagonalen ein Polygon in Dreiecke oder allgemeiner in Unterpolygone 
zerlegen. Diese Eigenschaft macht sich die \textbf{Triangulation} zu nutze. Allgemein beschreibt der Begriff Triangulation die Zerlegung eines 
topologischen Raumes in \textbf{Simplexe}.\cite{polytri3} Der topologische Raum ist in diesem Fall das Polygon, welches durch einen Streckenzug gebildet wird.

Als Simplex bezeichnet man das einfachste Polygon einer Dimension.\cite{simplex} Für die nullte Dimension ist das trivialerweise der Punkt. Da keine räumliche Ausdehnung 
möglich ist, ist der begrenzende Streckenzug hier nur der Punkt selbst.
In der ersten Dimension, in welcher Objekte eine Länge, aber keine Breite besitzen, ist der Streckenzug eine einzelne Strecke. Diese ist somit auch das Simplex dieser Dimension.
Für die zweite Dimension ist nun das Dreieck das Simplex. Es ist die Fläche, welche aus den wenigsten Punkten, verbunden duch Strecken, erzeugt werden kann und daher das einfachste Polygon dieser 
Dimension. 

Wie bereits beschrieben, kann jedes komplexere Polygon so durch Diagonalen zerlegt werden, dass es vollständig von Dreiecken repräsentiert wird. Das ist besonders günstig für 
eine Bearbeitung durch Computer, da ein Dreieck immer eindeutig durch seine drei Eckpunkte beschrieben wird. Wie später noch zu sehen sein wird, kann man in einem Polygon sehr einfach Dreiecke dadurch erzeugen, 
dass man Diagonalen einfügt. Man kann spezielle Dreiecke, die sogenannten Ears, sogar durch Hinzufügen von nur einer Diagonalen generieren, was algoritmisch gut beschreibbar ist.

Da in der Praxis nicht nur zweidimensionale sondern auch dreidimensionale Objekte eine Rolle spielen, stellt sich die folgende Frage. Kann man diese 3D-Objekte nicht auch in ebenfalls dreidimensionale 
Simplexe zerlegen? 

\begin{wrapfigure}{l}{0.25\textwidth}
  \centering
  \includegraphics[width=0.2\textwidth]{bilder/cube.png}
  \caption[Zerlegung eines Würfels in vier Tetraeder]{\centering Zerlegung eines Würfels in vier Tetraeder \cite{cubecut}}
  \label{fig:cubecut}
\end{wrapfigure}

Die Antwort ist ja, jedoch ist das nicht sonderlich nützlich. Natürlich existiert in der dritten Dimension auch ein Simplex. Dieses ist der Tetraeder. Man kann auch jedes Polytop 
dieser Dimension in Tetraeder zerlegen. Diese Zerlegung benötigt man durchaus für spezielle Anwendungen.  
Wöllte man das Innere eines Objektes durch die Zerlegung ebenfalls erhalten, beispielsweise einen Vollwürfel aus Holz in der 
Realität zersägen, dann wäre eine Tetraederzerlegung notwendig. Ein Beispiel für diese Art der Zerlegung ist in Abbildung \ref{fig:cubecut} zu sehen. 
Man benötigt diese Form der Zerlegung zwar für einige Anwendungen, wie etwa bei der finite Elemente Methode, jedoch soll das nicht Gegenstand der Betrachtung in dieser Arbeit sein.
Man kann die räumlich orientierte Oberfläche eines Würfels topologisch isomorph zu einem Würfelgitter aus quadratischen Flächen beschrieben. Diese Gesamtfläche lässt sich dann 
wiederum in Dreiecke zerlegen. Somit lässt sich auch die Oberfläche dreidimensionaler Objekte durch eine Triangulierung beschreiben. Das ist besonders gut geeigent für Computer, da man nur einen einzigen 
Algorithmus zur Bearbeitung von Flächen und Körpern benötigt, wenn man diese in Dreiecke zerlegen möchte.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{bilder/3DZerlegung.png}
  \caption[Zerlegung der Oberfläche eines Würfels in Dreiecke mittels Würfelgitter]{\centering Zerlegung der Oberfläche eines Würfels in Dreiecke mittels Würfelgitter}
  \label{fig:cubenet}
\end{figure}

\subsection{Slivers}

Bei Triangulationsalgorithmen wie dem \ac{eca} liegt der Fokus zunächst nicht in der Qualität der Zerlegung. Natürlich gibt es verbesserte Versionen wie beispielsweise in Kapitel 3.1 beschreiben wird.
In jedem Fall sind sogenannte \textbf{Slivers} jedoch ein negativer Einflussfkator, wenn es um qualitative Gesichtspunkte geht. Dreiecke haben in der Computergrfaik eine bestimmte Eigenschaft. Legt man eine Scanline 
durch ein Dreieck, dann schneitet diese die Kanten des Dreiecks in zwei Punkten. Diese zwei Schnittpunkte werden von zwei unterschiedlichen Pixeln auf dem Bildschirm repräsentiert. Somit lässt sich definieren, 
wo eine Fläche beginnt und wo sie endet und dies auf dem Bildschirm darstellen. Bei Slivers ist das nicht der Fall. Ihre Innenfläche ist so schmal,
dass die beiden Schnittpunkte der Scanline mit den Kanten des Dreiecks auf den selben Pixel fallen. \cite{sliverdef} Das führt in letzter Instanz zu Grafikfehlern. 

\begin{wrapfigure}{r}{0.54\textwidth}
  \centering
  \includegraphics[width=0.49\textwidth]{bilder/sliverScanline.png}
  \caption[Unterschied Sliver und normales Dreieck]{\centering (a) Scanline mit zwei separaten Schnittpunktpixeln (b) Sliver mit nur einem Pixel für beide Schnittpunkte}
  \label{fig:sliver}
\end{wrapfigure}

Der Begriff Sliver beschränkt sich nicht nur auf Dreiecke. Auch andere Simplexe wie Tetraeder können Slivers sein. Sie sind so flach, dass auch hier Darstellungsfehler entstehen.
Zusätzlich dazu gibt es noch den verwandten Begriff der \textbf{Neadle}, der einen sehr schmalen aber auch sehr spitzen Tetraeder bezeichnet.\cite{sliver} \linebreak

\subsection{Der Traditionelle Ear-Clipping-Algorithmus}

Der zentrale Fokus in dieser Arbeit liegt auf dem \ac{eca}. Dieser wurde von Meister in seiner Abhandlung \emph{Polygons have ears} \cite{meister} in seiner ursprünglichen Form beschrieben.
Der Algorithmus bestimmt Dreiecke, welche die Eigenschaft eines Ears erfüllen, fügt die dafür nötige Diagonale in eine Liste ein und löscht den Ear Tip aus der Liste aller noch nicht 
bearbeiten Punkte. Dies wird solange wiederholt, bis das Restpolygon nur noch aus drei Punkten besteht. Zuletzt wird die Liste der Diagonalen ausgegeben, da diese die Triangulation des Polygons erzeugt.
Der Algoritmus ist im Folgenden in Pseudocode dargestellt.

\begin{flushleft}
  { \textbf{Algorithmus 1: Traditionelles Ear-Clipping} \cite{improvedeca}
        \begin{tabbing}
          \=$~~~~~~$\= \textbf{Eingabe:} $~~~$\= Polyg\=on $P$ mit $n$ Ecken in einer Liste $L$\\
          \> \> \textbf{Ausgabe:} \> Liste $D$ mit $n-3$ Diagonalen, die eine Triangulierung bilden.\\
          \> \> \textbf{Schritt 1:} \>Sei $D := \emptyset$ Liste der Diagonalen.\\
          \> \> \textbf{Schritt 2:} \>\textbf{while} $|L| > 3$ \textbf{do}\\
          \> \>                     \> \> (a) Finde ein Ear $v_{i-1}, v_i, v_{i+1}$\\
          \> \>                     \> \> (b) $D := D \cup \left\{v_{i-1} v_{i+1}\right\}$\\
          \> \>                     \> \> (c) $L := L\setminus v_i$\\
          \> \> \> \textbf{endwhile}\\
          \> \> \textbf{Schritt 3:} \> Ausgabe von $D$ als triangulierende Diagonalen.
        \end{tabbing}
}
\end{flushleft}

Dieser Algoritmus hat einen Zeitaufwand von $O(n^3)$ mit einem Aufwand von $O(n^2)$ für das Ermitteln des Ear-Status eines Dreiecks. 
In dieser Formulierung wird nicht auf die Klassifikation eines Ears im speziellen eingegangen. Hierfür beginnt man klassisch 
beim ersten ersten Punkt in $L$. Man überprüft ob dieser Punkt $v_i$ konvex ist. Ist das der Fall, dann muss die Strecke $\left\{v_{i-1}v_{i+1}\right\}$ die Eigenschaft haben, 
eine Diagonale von $P$ zu sein. Wenn das ebenfalls zutrifft, dann ist das Dreiecke $v_{i-1}, v_i, v_{i+1}$ ein Ear. 
Man kann die Klassifikation so darstellen:

\begin{flushleft}
  { \textbf{Algorithmus 2: Ear Klassifikation}
        \begin{tabbing}
          \=$~~~~~~$ \= \textbf{Eingabe:} $~~~$\=  Ecken \=${v_i, v_{i-1}, v_{i+1}} \in L$  $~~~~~~~~$\= \\
          \> \> \textbf{Ausgabe:} \> $\triangle v_{i-1}, v_i, v_{i+1}$ ist Ear oder nicht.\\
          \> \> \textbf{Schritt 1:} \>\textbf{if} $v_i$ konvex \textbf{AND} $\left\{v_{i-1}v_{i+1}\right\}$ ist Diagonale von $P$\\
          \> \> \> \>Ausgabe $\triangle v_{i-1}, v_i, v_{i+1}$ ist Ear.\\
          \> \> \> \textbf{else} Ausgabe $\triangle v_{i-1}, v_i, v_{i+1}$ ist kein Ear.\\
          \> \> \> \textbf{endif}\\
        \end{tabbing}
}
\end{flushleft}\pagebreak
Diese Klassifikation könnte man auch zuerst über alle Punkte $v_i$ in $L$ laufen lassen. Man spricht dann von der Klassifikationsphase. 
Danach kann man in einer zweiten Phase, der Cutting-Phase, Dreicke auswählen, welche die Ear-Eigenschaft erfüllen und sich nicht überschneiden, 
und diese dann abschneiden. Mit diesen beiden Phasen im Wechsel kann man ebenfalls eine Triangulation erreichen. 
O'Rourke beschreibt in seinem Buch einen Ansatz, der einige Zeitersparnis bei diesem Algorithmus bewirkt.\cite{orourke}
Anstatt nach dem Abtrennen eines Ear Tip Punkts den Status jedes Eckpunktes erneut zu überprüfen, muss man nur den Status von $v_{i-1}$ und $v_{i+1}$ erneut betrachten.
Nur diese beiden Punkte sind nämlich vom Abtrennen von $v_i$ beeinflusst. Somit benötigt man insgesamt nurnoch eine Zeit von $O(n^2)$.\cite{newAlg} 
In jedem Cutting-Schritt kann man dann zusätzlich entscheiden, welches Dreieck als nächstes ausgewählt werden soll. So könnte man nur die Dreiecke auswählen, welche einer bestimmten Heuristik entsprechen.
Beispielsweise könnten so nur Dreiecke gewählt werden, bei denen der kleinste Innenwinkel das Maximum aller aktuell verfügbaren Innenwinkel ist. Auf diese Weise ist es denkbar,
dass man Sliver vermeiden könnte. Andere Ansätze sind exemplarisch in Kapitel 3 aufgeführt.

\subsection{Preprocessing für Polygone mit Löchern}

Neben einfachen Polygonen, wie sie bisher in dieser Arbeit beschrieben worden sind, gibt es auch komplexere Formen. Held bezeichnet sie in seiner Abhandlung über \ac{fist} als \emph{multiply-connected polygonal areas}, 
also als mehrfach verbundene polygoniale Flächen.\cite{fist} Der Einfachkeit halber sollen eben diese zusammengesetzten Polygone in dieser Arbeit entweder als \textbf{komplexe Polygone} oder als \textbf{Polygone mit Loch} bezeichnet werden.
Ein solches Loch wird dabei ebenfalls durch einen geschlossenen Streckenzug begrenzt und ist somit selbst ein Polygon. Ein Loch $H$ hat allerdings die Eigenschaft bereits im Inneren eines anderen Polygons $P$ zu liegen, ohne dabei mit dem äußeren 
Streckenzug von $P$ verbunden zu sein oder diesen zu schneiden. 

Da diese beiden Streckenzüge keine Kante besitzen, welche sie verbindet, ergibt sich ein Problem für den \ac{eca}, welcher nur mit einem geschlossenen Polygonzug und dessen Ecken arbeitet. Um den \ac{eca} dennoch auch auf komlexe Polygone anwenden zu können,
bedarf es der Vorbereitung durch einen anderen Algorithmus, um aus den endlich vielen verschiedenen Streckenzügen von $P$ und den $i$ Löchern $H_i$ zu erzeugen.
M. Held beschreibt in seiner Arbeit zwei verschiedene Verfahren mit dem selben Grundgedanken. Man fügt dazu zusätzliche Kanten, sogenannte \textbf{Brücken} (contour bridges) zwischen je einer Ecke $v_i$ von $P$ und einer Ecke $u_j$ eines Loches $H$ ein. Diese Kante sei dann $\left\{v_iu_j\right\} \in E(P')$
Damit man den Streckenzug, der daraus entsteht weiter entlang laufen kann, ohne eine Kante doppelt zu nutzen, muss man die Brücke sozusagen doppelt einfügen. Hierzu erzeugt man Kopien $v_i', u_j'$ von $v_i, u_j$ und verbindet diese ebenfalls mit einer Brücke, 
allerdings mit umgekehrter Orientierung, $\left\{u_j'v_i'\right\} \in E(P')$. $P'$ sei dabei das neu entstandene Polygon aus der Vereinigung $E(P)\cup E(H) \cup \left\{ \left\{v_iu_j\right\},\left\{u_j'v_i'\right\} \right\} $.

\begin{figure}
  \centering
  \includegraphics[width=1\textwidth]{bilder/bridges.png}
  \caption[Vereinfachung eines Polygons mit mehreren Löchern zu einem einfachen Polygon]{\centering (a) Polygon mit mehrerern Löchern. Brücken gestrichelt dargestellt. (b) Resultierendes Polygon (Durchlaufrichtung entlang des Streckenzugs mittels Pfeilen gekennzeichnet)\cite{fist}}
  \label{fig:bridges}
\end{figure}

Der erste Ansatz, um ein Loch $H$ mit dem Polygon $P$ zu verbinden, beruht auf einer vollständigen Enumeration. Man bildet alle Paare von Punkten $(v_i,u_j)$ und verbindet diese mit einer vorläufigen Strecke. Dann berechnet man die Länge aller dieser Strecken und wählt die kürzeste von ihnen als Brücke.
Dabei muss überprüft werden, dass die gewählte Strecke keine Kante von $P$ oder $H$ schneidet. Sollte es einen Schnittpunkt geben, wird die zweit längste Strecke überprüft und so weiter. Bei diesem Verfahren kommt man auf eine Komplexität von $O(n^3)$ wobei es $O(n^2)$ viel mögliche Strecken gibt und man 
lineare Zeit benötigt, um eine Brücke als valide zu klassifizieren. Hat man mehr als ein Loch, so beginnt man mit einem beliebigen und verbindet es mit $P$ und wählt dann das nächste aus, bis alle Löcher und $P$ zum Polygon $P'$ vereinigt worden sind.

Da diese Laufzeit sehr unzufriedenstellend ist, schlägt Held ein zweites Verfahren vor, welches er auch bei der Implementierung von \ac{fist} verwendet.
Hierfür bestimmt man für jedes Loch $H_j$ den am weitesten links liegenden Eckpunkt $u_{left}$. Dann werden die Löcher nach eben diesen Punkten sortiert, von links nach rechts in aufsteigender Reihenfolge. Eine solche Sortierung ist in Abbildung \ref{fig:bridges} zu sehen.
Man beginnt dann mit dem Loch mit der Nummer eins $H_1$ mit der Verbinung mit $P$. Dazu bestimmt man alle Punkte $v_i$ von $P$, welche links von $u_{left}$ liegen und sortiert diese nach ihrem Abstand zu $u_{left}$.
Beginnen mit dem am wenigsten entfernten Punkt, $v_1$, wird dann überprüft, ob $\left\{v_iu_{left}\right\}$ eine Brücke ist. Die Sortierung der Punkte $v_i$ soll dafür sorgen, dass möglichst wenig solcher Paare überprpft werden müssen.
Führt man diesen Algorithmus für alle $i$ Löcher durch, so erhält man im schlimmsten Fall eine Laufzeit von $O(i\cdot n^2)$.

Ein noch effizienterer Ansatz, welcher auch bei der Umsetzung dieser Arbeit berücksichtigt wird, wurde von David Eberly in seiner Veröffentlichung \emph{Triangulation by Ear Clipping} beschrieben.\cite{eberly}
Zum Bestimmen der zwei Punkte, welche das Loch $H$ und das äußere Polygon $P$ mit einer Brücke verbinden sollen nutzt er eine Herangehensweise, welche mit einer Halbgerade als Sichtlinie arbeitet.
Zunächst bestimmt der Algoritmus von Eberly den Eckpunkt $u$ des Loches $H$ mit der größten x-Koordinate. Dieser soll Ausgangspunkt für die Sichtlinie sein. Diese Verläuft entlang positiver X-Richtung und kann somait als $r_u = u + t \cdot (1,0)$ beschrieben werden.
Der sich ergebende Schnittpunkt von $r_u$ mit den Kanten des Polygons $P$ soll mit $i$ bezeichnet werden. 

%Bild fig 12 mit modifikation M=u, I=i, P=w, x=r_u
\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{bilder/bridgefindigwithray.png}
  \caption[Brücken finden mittels Sichtlinie]{\centering Nähester Sichtbarer Punkt $w$ zu Punkt $u$ des Lochs. \cite{eberly}}
  \label{fig:bridgeray}
\end{figure}

Für diesen Punkt gibt es nun zwei Möglichkeiten. Entweder $i$ ist Eckpunkt von $P$ oder $i$ liegt auf einer Kante von $P$.
Im ersten Fall muss $i$ für $u$ sichtbar sein und somit wird die Kante zwischen diesen beiden Punkten die Brücke zwischen $H$ und $P$. Auch diese muss doppelt vorhanden sein, wie bereits zuvor beschrieben.
Der zweite Fall, bei dem $i$ auf einer Kante $v_iv_{i+1}$ liegt bedarf näherer Betrachtung. Hierfür wird ebenfalls wieder der eine der beiden Punkte bestimmt, welcher die größere x-Koordinate besitzt. 
Es kann sein, dass der so ausgewählte Punkt $w$ nicht für $u$ sichtbar ist. Das ist dann der Fall wenn sich im Dreieck $\triangle uwi$ konkave Eckpunkte von $P$ befinden. Die Kanten, zu denen diese Eckpunkte gehören, blockieren dann die Sicht auf $w$.
Daher muss überprüft werden, ob keine solchen PUnkte im inneren des besagten Dreiecks liegen. Ist dem so, dann ist $w$ der gesuchte Punkt für die Brücke zu $u$. Sollten sich konkave Punkte im Inneren von $\triangle uwi$ befinden, dann wird der jenige gesucht, 
der den Abstand zu $u$ minimiert. Einen solchen Punkt muss es immer geben und dieser ist dann sichtbar für $u$ und eigent sich somit für eine Brücke.
In Abbildung \ref{fig:wNotVisible} kommen die Punkte $a,b$ und $c$ also neue Kandidate in Frage. Für $a$ ist der Abstand zu $u$ minimal. Der eben beschriebene Algorithmus ist im Folgenden noch einmal in Pseudocode dargestellt.
%Bild fig 13 mit modifikationen m=u, I=i, x=r_u, p=w, A=a, B=b, C=c

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{bilder/blockedray.png}
  \caption[Ermittlung eines Ersatzpunktes, wenn die Sicht blockiert ist]{\centering Sichtlinie von $u$ nach $w$ ist durch äußeres Polygon blockiert. Konkave Punkte $a, b, c$ sind Kandidaten für die Brückenbildung. 
  Abstand von $a$ nach $u$ ist minimal.\cite{eberly}}
  \label{fig:wNotVisible}
\end{figure}\break

\begin{flushleft}
  { \textbf{Algorithmus 3: Ermittlung von Brückenknoten mittels Sichtlinie\cite{eberly}}
        \begin{tabbing}
          \=$~~~~~~$ \= \textbf{Eingabe:} $~~~$\=  Eck\=en $v_i$\=$ \in V$\=$(P)$, Ecken $u_i \in V(H)$\\
          \> \> \textbf{Ausgabe:} \> Kanten $E(P')$\\
          \> \> \textbf{Schritt 1:} \> Wähle $u_i$ mit maximaler x-Koordinate aller $u_i \in V(H)$\\
          \> \> \textbf{Schritt 2:} \> Bestimme ersten Schnittpunkt $i$ von $r_u = u_i + t \cdot (1,0),$\\
          \> \> \> $~(t \in \mathbb{R})$ mit $e \in E(P)$\\
          \> \> \textbf{Schritt 3:} \> Bestimme Eckpunkte von $e$: $v_{1,e},~v_{2,e}$\\
          \> \> \textbf{Schritt 4:} \> \textbf{if} $i = v_{1,e}$ OR $i = v_{1,e}$\\
          \> \> \> \> Ausgabe $E(P') := E(P) \cup iu_i \cup E(H) \cup u_ii$\\
          \> \> \>\textbf{else}\\
          \> \> \textbf{Schritt 5:} \> \> Bestimme Punkt mit maximaler x-Koordinate\\
          \> \> \> \> von $v_{1,e},~v_{2,e}$ als Punkt $w$\\
          \> \> \textbf{Schritt 6:} \> \> Bestimme $\triangle u_iiw$\\
          \> \> \textbf{Schritt 7:} \> \> \textbf{if} Keine Punkte von $P$ im Inneren $I_\triangle u_iiw$ von $\triangle u_iiw$\\
          \> \> \> \> \> \> Ausgabe $E(P') := E(P) \cup wu_i \cup E(H) \cup u_iw$\\
          \> \> \> \>\textbf{else}\\
          \> \> \textbf{Schritt 8:} \> \> \> \> Bestimme alle konkaven Punkte in $I_\triangle u_iiw$\\
          \> \> \textbf{Schritt 9:} \> \> \> \> Bestimme Punkt $a \in I_\triangle u_iiw \cap E(P)$ mit minimalem Abstand zu $u_i$\\
          \> \> \textbf{Schritt 10:} \> \> \> \> Ausgabe $E(P') := E(P) \cup au_i \cup E(H) \cup u_ia$\\
          \> \> \> \> \textbf{endif}\\
          \> \> \>\textbf{endif}\\

        \end{tabbing}
}
\end{flushleft}

Durch das Einfügen von Brückenkanten können zwar das Polygon $P$ und alle Löcher $H_i$ verbunden werden und als ein einziges Polygon $P'$ behandelt werden, nur ergibt sich ein neues Problem.
Laut der Definition eines einfachen Polygons (s. Kapitel 2.1.1) ist es nicht erlaubt, dass sich Kanten schneiden oder berühren. Da aber die Brückenkanten doppelt vorhanden sind, also an der exakt gleichen Position
befinden, ist das Polygon $P'$ kein einfaches solches mehr. Man bezeichnet es als \textbf{schwach einfach} (weakly simple)\cite{weaklysimple}. Diese Polygone können per Definition durch eine beliebige minimale Änderung $\epsilon$ in einfache Polygone 
umgewandelt werden. Diese Änderung $\epsilon$ kann eine Verschiebung der Eckpunkte der Brücken um eine kleine Konstante sein, sodass sich die doppelten Kanten nicht mehr berühren. Dazu ist es notwendig die ursprünglichen 
Positionen dieser Punkte zu speichern, damit diese in der Nachbearbeitung wieder an ihre eigentlichen Koordinaten zurück verschoben werden können.
